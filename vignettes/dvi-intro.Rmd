---
title: "The {dvi} Package"
author: "Paul Murrell"
output: 
  rmarkdown::html_vignette:
    number_sections: true
bibliography: dvi-intro.bib
vignette: >
  %\VignetteIndexEntry{The {dvi} Package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r echo=FALSE}
knitr::opts_chunk$set(
  comment = ''
)
```

*The {dvi} package reads the DVI files that are produced by TeX engines.
It produces a human-friendly print out of the contents of a DVI file
and it generates an R list representing the contents of a DVI file.
This is useful for inspecting and debugging 
DVI files and for processing DVI files in R.*

# What is a DVI file?

In typical modern usage of LaTeX [@latex:lamport1994], 
the more convenient front-end to the TeX typesetting system [@tex:knuth1984],
a source LaTeX document is processed directly to
a typeset PDF document for viewing and printing.  For example, 
suppose we have a LaTeX file called `demo.tex`, which is shown below.

```{r echo=FALSE}
cat(readLines("demo.tex"), sep="\n")
```

The following command processes the LaTeX file and produces a PDF
document called `demo.pdf`, which is shown below the command.

```{bash results="hide"}
pdflatex demo.tex
```
```{bash echo=FALSE, results="hide"}
convert -density 200 demo.pdf demo-pdf.png
```

![](demo-pdf.png)

However, we do not have to directly produce a PDF document.
For example, instead of producing a PDF document,
the following command produces a DVI file called `demo.dvi`.

```{bash results="hide"}
latex demo.tex
```

This DVI file is a "device independent" intermediate format that contains
information from typesetting the LaTeX document:
which fonts to use, which glyphs to use from those fonts,
and the position of each glyph [@Fuchs:TB2-2-12].

A DVI file can be processed to create a variety of formats for 
viewing and printing.  For example, the following command 
processes the DVI file called `demo.dvi` to produce a PDF document,
similar to the one that we created above.

```{bash results="hide"}
dvipdf demo.dvi demo-dvi.pdf
```

The command below processes
the DVI file called `demo.dvi` to produce a PostScript document
instead of a PDF document.
The PostScript document, called `demo.ps`, is shown below the command.

```{bash results="hide"}
dvips -E demo.dvi 
```
```{bash echo=FALSE, results="hide"}
convert -density 200 demo.ps demo-ps.png
```

![](demo-ps.png)

# Viewing DVI files

The DVI file format is binary, so to most software
the contents of the DVI file
`demo.dvi` are just a series of bytes.
The first 102 bytes of `demo.dvi` are shown below.

```{r echo=FALSE}
library(hexView)
viewRaw("demo.dvi", nbytes=102)
```

One purpose of the {dvi} package is to print a human-readable version
of a DVI file.  The `readDVI()` function reads a DVI file into
R and prints the contents in a readable format.
For example, the following code reads the DVI file
called `demo.dvi` and prints its contents.
We can now see that a DVI consists of a series of *operations* (the
left column), with some operations having a set of *parameters*
(the right column).
An unofficial description of the DVI file format is available
from the [Internet Archive](https://web.archive.org/web/20070403030353/http://www.math.umd.edu/~asnowden/comp-cont/dvi.html)
In the output below, we can see the text from the LaTeX source being
typeset as a series
of `set_char` operations.

```{r}
library(dvi)
```

```{r}
readDVI("demo.dvi")
```

Inspecting a DVI file is useful for understanding how different TeX
engines work.  The DVI file above was generated by the pdfTeX engine
[@pdftex:thanh2000],
which is the modern default.  The following code typesets the LaTeX 
document using the XeTeX engine instead [@xetex:kew2008].  The result is an 
"extended" DVI file called `demo.xdv`.

```{bash results="hide"}
xelatex -no-pdf demo.tex
```

The following code uses the `readDVI()` function to read and
print the file `demo.xdv`.
In this file, the text from the LaTeX source is typeset
as a series of `x_glyph` operations rather than the `set_char` operations
that we saw in `demo.dvi`.

```{r}
readDVI("demo.xdv")
```

The {dvi} package can read DVI files that are generated by any of the
following TeX engines:  pdfTeX, e-upTeX [@euptex:dev], 
LuaTeX [@luatex:manual], and XeTeX.

# Accessing DVI files

The return value from the `readDVI()` function is a `"DVI"` object,
which is a list of the DVI operations from the DVI file in R object form.
Each component of the list, each DVI operation, is a low-level memory block
object.  For example, the first operation in the `demo.dvi` file 
is shown below.

```{r}
dvi <- readDVI("demo.dvi")
dvi[[1]]
```

The values within the memory block can be accessed using functions
from the {hexView} package, but three convenience functions are
provided to get access to the most important values.
The `opCode()` function returns all of the operation codes
from a `"DVI"` object,
as a numeric vector, 
the `opNames()` function converts codes to slightly more interpretable
operation names,
and the `opParams()` function returns all of
the operation parameters as a list of named lists.
For example, the following code extracts all of the operation codes
from the DVI file `demo.dvi`, converts them to operation names,
and then displays the parameters
for the first operation.

```{r}
codes <- opCodes(dvi)
codes
opNames(codes)
opParams(dvi)[[1]]
```

# Processing DVI files

We can process the `"DVI"` object that `readDVI()` produces to 
explore the typeset information that the TeX engines produce.
As a very simple example, the following code determines the number
of pages in the DVI file `demo.dvi` by counting the number of `"bop"`
(beginning of page) operations in the file.

```{r}
numPages <- sum(opNames(codes) == "bop")
numPages
```

As a much more complicated example, the following code
extracts font and glyph information from the `demo.xdv` file
and draws the first four glyphs
in R (bottom-left aligned in the centre of the image).
The code also draws a label at the bottom of the image
to show that this is an image drawn by R as opposed to the images
drawn by TeX tools
like `pdflatex` or `dvipdf` that we saw in Section 1.

```{r, fig.width=1, fig.height=.5, dpi=200, message=FALSE}
xdv <- readDVI("demo.xdv")
codes <- opCodes(xdv)
names <- opNames(codes)
params <- opParams(xdv)
pre <- params[names == "pre"][[1]]
fontDef <- params[names == "x_fnt_def"][[1]]
glyphs <- params[names == "x_glyph"][[1]]
convertX <- function(x, state) {
    factor <- with(pre, num/den*1000/mag/10^4)
    x*factor/25.4*72
}
font <- glyphFont(file=paste(fontDef$fontinfo.marker.fontname.block, 
                             collapse=""), 
                  index=fontDef$fontinfo.marker.fontindex, 
                  family="", weight=400, style="plain")
info <- glyphInfo(id=glyphs$glyphs.id, 
                  x=convertX(c(glyphs$glyphs.xy1, 
                               glyphs$glyphs.xy3, 
                               glyphs$glyphs.xy5, 
                               glyphs$glyphs.xy7)),
                  y=rep(0, 4), 
                  font=1, 
                  size=convertX(fontDef$ptsize), 
                  fontList=glyphFontList(font),
                  width=20, height=10)
library(grid)
grid.newpage()
grid.glyph(info, hjust=0, vjust=0)
grid.text("This is R", y=unit(.5, "lines"), gp=gpar(cex=.5))
```

Drawing the complete typeset result from the DVI file is a lot more
involved, so that is left to other packages.
Some experiments along those lines include the
[{dvir}](https://github.com/pmur002/dvir) package
[@murrell-dvir; @murrell-dvir-luatex-2020; @murrell-dvir-tikz-2020]
and the
[{latex}](https://github.com/pmur002/latex) package (under development).

# Related tools

It is possible to view the contents of DVI files, in a human readable
format, using tools that are typically part of a TeX distribution
(e.g., [TeX Live](https://www.tug.org/texlive/)).
For example, `dvitype`, `dv2dt`, and
`dviasm` produce a text version of a binary DVI file. 
The latter also allows editing the text and converting back to a binary
DVI file, plus there is a `dt2dv` partner for `dv2dt`.

The main difference compared to viewing the contents of a DVI file
with `readDVI()` is the format of the text.
There is no function in the {dvi} package to regenerate a binary DVI from 
a human-readable version.

We saw in Section 1 that there are TeX tools like `dvipdf` and `dvips`
for generating PDF
or PostScript documents from DVI files.

The {patchDVI} package [@pkg-patchDVI]
is another R package that can read DVI files.
This package is focused on a specific processing task for
the information within DVI files (providing links between rendered
typeset output and the original source file).
It has a `readDVI()` function, but that only prints a limited subset of 
the operations within a DVI file and does not return an R object.

In Section 4, we saw that the return value from `readDVI()` is an R
object that can be used for processing the contents of a DVI file.
Essentially, this means that tools for working with DVI files can
be developed in R, including tools for rendering DVI files as
part of R graphics output.

# References
