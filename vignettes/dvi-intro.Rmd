---
title: "The {dvi} Package"
author: "Paul Murrell"
output: 
  rmarkdown::html_vignette:
    number_sections: true
bibliography: dvi-intro.bib
vignette: >
  %\VignetteIndexEntry{The {dvi} Package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r echo=FALSE}
knitr::opts_chunk$set(
  comment = ''
)
```

*The {dvi} package reads the DVI files that are produced by TeX engines.
It produces a human-friendly print out of the contents of a DVI file
and it generates an R list representing the contents of a DVI file.
This is useful for inspecting and debugging 
DVI files and for processing DVI files in R.*

# What is a DVI file?

In typical modern usage of LaTeX [@latex:lamport1994], 
the more convenient front-end to the TeX typesetting system [@tex:knuth1984],
a source LaTeX document is processed directly to
a typeset PDF document for viewing and printing.  For example, 
suppose we have a LaTeX file called `demo.tex`, which is shown below.

```{r echo=FALSE}
cat(readLines("demo.tex"), sep="\n")
```

The following command processes the LaTeX file and produces a PDF
document called `demo.pdf`, which is shown below the command.

```{bash results="hide"}
pdflatex demo.tex
```
```{bash echo=FALSE, results="hide"}
convert -density 200 demo.pdf demo-pdf.png
```

![](demo-pdf.png)

However, we do not have to directly produce a PDF document from a LaTeX
source file.
For example, instead of producing a PDF document,
the following command produces a DVI file called `demo.dvi`.

```{bash results="hide"}
latex demo.tex
```

This DVI file is a "device independent" intermediate format that contains
information from typesetting the LaTeX document:
which fonts to use, which glyphs to use from those fonts,
and the position of each glyph [@Fuchs:TB2-2-12].

A DVI file can be processed to create a variety of formats for 
viewing and printing.  For example, the following command 
processes the DVI file called `demo.dvi` to produce a PDF document,
similar to the one that we created above.

```{bash results="hide"}
dvipdf demo.dvi demo-dvi.pdf
```

The command below processes
the DVI file called `demo.dvi` to produce a PostScript document
instead of a PDF document.
The PostScript document, called `demo.ps`, is shown below the command.

```{bash results="hide"}
dvips -E demo.dvi 
```
```{bash echo=FALSE, results="hide"}
convert -density 200 demo.ps demo-ps.png
```

![](demo-ps.png)

# Viewing DVI files

The DVI file format is binary, so for most software
a DVI file like
`demo.dvi` is just a series of bytes.
For example, the first 100 bytes of `demo.dvi` are shown below.
We can see what looks like some simple ASCII bytes in the file, but also
a lot of other bytes that require a more complex interpretation.
An unofficial description of the DVI file format is available
from the [Internet Archive](https://web.archive.org/web/20070403030353/http://www.math.umd.edu/~asnowden/comp-cont/dvi.html).

```{r echo=FALSE}
library(hexView)
viewRaw("demo.dvi", nbytes=100)
```

One purpose of the {dvi} package is to interpret the byte structure
of a DVI file and print a human-readable version.
The `readDVI()` function reads a DVI file into
R and prints the contents in a text format.
For example, the following code reads the DVI file
called `demo.dvi` and prints its contents.
We can now see that a DVI consists of a series of *operations* (the
left column), with some operations having a set of *parameters*
(the right column).
In the output below, we can see the text from the LaTeX source being
typeset as a series
of `set_char` operations.

```{r}
library(dvi)
```

```{r}
readDVI("demo.dvi")
```

Inspecting a DVI file is useful for understanding how different TeX
engines work.  The DVI file above was generated by the pdfTeX engine
[@pdftex:thanh2000],
which is default engine in modern TeX distributions.  
The following code typesets the LaTeX 
document using the XeTeX engine instead [@xetex:kew2008].  The result is an 
"extended" DVI file called `demo.xdv`.

```{bash results="hide"}
xelatex -no-pdf demo.tex
```

The following code uses the `readDVI()` function to read and
print the contents of the file `demo.xdv`.
In this file, the text from the LaTeX source is typeset
as a series of `x_glyph` operations rather than the `set_char` operations
that we saw in `demo.dvi`.

```{r}
readDVI("demo.xdv")
```

The {dvi} package can read DVI files that are generated by any of the
following TeX engines:  pdfTeX, e-upTeX [@euptex:dev], 
LuaTeX [@luatex:manual], and XeTeX.

# Accessing DVI files

The return value from the `readDVI()` function is a `"DVI"` object,
which is a list of the DVI operations from the DVI file in R object form.
Each component of the list, each DVI operation, is a `"rawFormat"`
object from the {hexView} package
[@Rnews:Murrell:2007].  Each `"rawFormat"` object
is a list with a `blocks` component that is itself a list of
`"rawBlock"` objects that contain the operation code and any parameters. 
For example, the first operation in the `demo.dvi` file 
is shown below. This operation has an operation code and 6 parameters.

```{r}
dvi <- readDVI("demo.dvi")
op1 <- dvi[[1]]
op1
```

We can select individual memory blocks by index or by name.
For example, the first memory block is the operation code, which is
labelled `op.opcode`.

```{r}
names(op1$blocks)
op1$blocks[[1]]
op1$blocks$op.opcode
```

Each `"rawBlock"` is a list that contains the raw bytes from the memory block,
the `fileRaw` component, plus
information about how those bytes should be interpreted.
The `blockValue()` function extracts the interpreted value from the
raw bytes.
For example, the operation code for each operation is a single byte
that is interpreted as an integer value.

```{r}
op1$blocks$op.opcode$fileRaw
blockValue(op1$blocks$op.opcode)
```

The {dvi} package provides three convenience functions 
for accessing the most important values from a `"DVI"` object.
The `opCode()` function returns all of the operation codes,
as a numeric vector, 
the `opNames()` function converts codes to slightly more interpretable
operation names,
and the `opParams()` function returns all of
the operation parameters as a list of named lists.
For example, the following code extracts all of the operation codes
from the DVI file `demo.dvi`, converts them to operation names,
and then displays the parameters
for the first operation.

```{r}
codes <- opCodes(dvi)
codes
opNames(codes)
opParams(dvi)[[1]]
```

# Processing DVI files

We can process the `"DVI"` object that `readDVI()` produces to 
explore the typeset information that the TeX engines produce.
As a very simple example, the following code determines the number
of pages in the DVI file `demo.dvi` by counting the number of `"bop"`
(beginning of page) operations in the file.

```{r}
numPages <- sum(opNames(codes) == "bop")
numPages
```

As a much more complicated example, the following code
extracts font and glyph information from the `demo.xdv` file
and draws the first four glyphs
in R (bottom-left aligned in the centre of the image).
The code also draws a label at the bottom of the image
to show that this is an image drawn by R as opposed to the images
drawn by TeX tools
like `pdflatex` or `dvipdf` that we saw in Section 1.

```{r, fig.width=1, fig.height=.5, dpi=200, message=FALSE}
xdv <- readDVI("demo.xdv")
codes <- opCodes(xdv)
names <- opNames(codes)
params <- opParams(xdv)
pre <- params[names == "pre"][[1]]
fontDef <- params[names == "x_fnt_def"][[1]]
glyphs <- params[names == "x_glyph"][[1]]
convertX <- function(x, state) {
    factor <- with(pre, num/den*1000/mag/10^4)
    x*factor/25.4*72
}
font <- glyphFont(file=paste(fontDef$fontinfo.marker.fontname.block, 
                             collapse=""), 
                  index=fontDef$fontinfo.marker.fontindex, 
                  family="", weight=400, style="plain")
info <- glyphInfo(id=glyphs$glyphs.id, 
                  x=convertX(c(glyphs$glyphs.xy1, 
                               glyphs$glyphs.xy3, 
                               glyphs$glyphs.xy5, 
                               glyphs$glyphs.xy7)),
                  y=rep(0, 4), 
                  font=1, 
                  size=convertX(fontDef$ptsize), 
                  fontList=glyphFontList(font),
                  width=20, height=10)
library(grid)
grid.newpage()
grid.glyph(info, hjust=0, vjust=0)
grid.text("This is R", y=unit(.5, "lines"), gp=gpar(cex=.5))
```

Drawing the complete typeset result from a DVI file is a lot more
involved, so that is left to other packages, for example, the
[{latex}](https://github.com/pmur002/latex) package (under development).

# Related tools

It is possible to view the contents of DVI files, in a human readable
format, using tools that are typically part of a TeX distribution
(e.g., [TeX Live](https://www.tug.org/texlive/)).
For example, `dvitype`, `dv2dt`, and
`dviasm` produce a text version of a binary DVI file. 
The latter also allows editing the text and converting back to a binary
DVI file, plus there is a `dt2dv` partner for `dv2dt`.

The main difference compared to viewing the contents of a DVI file
with `readDVI()` is the format of the text.
There is no function in the {dvi} package to regenerate a binary DVI from 
a human-readable version.

In terms of software for processing DVI files,
we saw in Section 1 that there are TeX tools like `dvipdf` and `dvips`
for generating PDF
or PostScript documents from DVI files.

The {patchDVI} package [@pkg-patchDVI]
is another R package that can read DVI files.
This package is focused on a specific processing task for
the information within DVI files (providing links between rendered
typeset output and the original source file).
It has a `readDVI()` function, but that only prints a limited subset of 
the operations within a DVI file and does not return an R object.

In Section 4, we saw that the return value from `readDVI()` is an R
object that can be used for processing the contents of a DVI file.
Essentially, this makes it possible to develop
tools for processing DVI files in R code, 
including, for example, tools for rendering DVI files as
part of R graphics output.

# References
